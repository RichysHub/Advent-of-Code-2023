use 00-25, and then x26
"zzzzz" -> 11881375, well within max value

can get back values with division and modulo
<https://www.dcode.fr/base-26-cipher>

int-division by powers of 26 removes digits, ie characters
"two" // 26 -> "tw"
"two" // 26*26 -> "t"

These powers of 26 are the encoding of "BA", "BAA", etc
last n-digits can be obtained by % B, followed by n As

"three" // 456976 -> "t"
"three" % 456976 -> "hree"

26 is an awkward # to get on stack, 47*2-, quicker to grab with something like 11g

some carefulness needed for handling first letter and generating the encoded value on stack
probably a sentinel value on top of the total? 
get input, move window, add input
check full window against "eight", "seven", "three".
check window % "BAAAA" against "four", "five, "nine" 
check window % "BAAA" against "six", "one", "two"
repeat

checks are just: dupe, push value of "six" etc, subtract, check for 0.

getting base-26 encoded number words onto the stack.

naive:
11g:"ta"-*"wa"-+\*"oa"-+  24 cells vs 2"OU"** 7 cells

hand worked improvements for conciseness:
  one = 9806       =  b*d + 6
  two = 13430      =  O*U*2
  three = 8817176  =  E*~*~*8 + 53624
  four = 97881     =  ;*O*3*7
  five = 93838     =  8*f*s - 2
  six = 12399      =  |*d - 1
  seven = 8310185  =
  eight = 1972769  =
  nine = 234238    =  z*x*8*2 - 2

solutions for one, two, four, five, six are potentially optimal

using <https://github.com/Mikescher/Befunge_Number_Representations>:
  one   = 6"bd"*+
  two   = 2"UO"**
  three = "OQ;-)"***\-
  four  = ";0"37***
  five  = "fs"8**2-
  six   = "|d"*1-
  seven = "Ir//!"***\-
  eight = "qV~M"+**6+9+
  nine  = "\C&"**6+

  BA    = 26      = 47*2-
  BAA   = 676     = 47*2-:*
  BAAA  = 17576   = "h~+"+*
  BAAAA = 456976  = "h~a,"*+*